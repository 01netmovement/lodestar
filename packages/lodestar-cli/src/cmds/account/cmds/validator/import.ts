import fs from "fs";
import path from "path";
import {CommandBuilder} from "yargs";
import inquirer from "inquirer";
import {Keystore} from "@chainsafe/bls-keystore";
import {
  YargsError,
  stripOffNewlines,
  writeFile600Perm,
  recursivelyFindVotingKeystores
} from "../../../../util";
import {VOTING_KEYSTORE_FILE} from "../../../../validatorDir/paths";
import {IAccountValidatorOptions} from "./options";
import {getAccountPaths} from "../../paths";

export const command = "import";

export const description = "Imports one or more EIP-2335 passwords into a Lodestar validator client directory, \
requesting passwords interactively. The directory flag provides a convenient \
method for importing a directory of keys generated by the eth2-deposit-cli \
Python utility.";

interface IValidatorCreateOptions extends IAccountValidatorOptions {
  keystore?: string;
  directory?: string;
}

export const builder: CommandBuilder<{}, IValidatorCreateOptions> = {
  keystore: {
    describe: "Path to a single keystore to be imported.",
    normalize: true,
    conflicts: ["directory"],
    type: "string"
  },

  directory: {
    describe: "Path to a directory which contains zero or more keystores \
for import. This directory and all sub-directories will be \
searched and any file name which contains 'keystore' and \
has the '.json' extension will be attempted to be imported.",
    normalize: true,
    conflicts: ["keystore"],
    type: "string"
  }
};

/* eslint-disable no-console */

export async function handler(options: IValidatorCreateOptions): Promise<void> {
  const singleKeystorePath = options.keystore;
  const directoryPaths = options.directory;
  const {keystoresDir, secretsDir} = getAccountPaths(options);

  const keystorePaths = singleKeystorePath
    ? [singleKeystorePath]
    : directoryPaths
      ? recursivelyFindVotingKeystores(directoryPaths)
      : null;

  if (!keystorePaths) {
    throw new YargsError("Must supply either keystore or directory");
  }
  if (keystorePaths.length === 0) {
    throw new YargsError("No keystores found");
  }

  // For each keystore:
  //
  // - Obtain the keystore password, if the user desires.
  // - Copy the keystore into the `validator_dir`.
  //
  // Skip keystores that already exist, but exit early if any operation fails.
  let numOfImportedValidators = 0;

  if (keystorePaths.length > 1) {
    console.log(`
${keystorePaths.join("\n")}

Found ${keystorePaths.length} keystores in \t${directoryPaths}
Importing to \t\t${keystoresDir}
`);
  }

  for (const keystorePath of keystorePaths) {
    const keystore = Keystore.fromJSON(fs.readFileSync(keystorePath, "utf8"));
    const pubkey = keystore.pubkey;
    const uuid = keystore.uuid;
    if (!pubkey) {
      throw Error("Invalid keystore, must contain .pubkey property");
    }
    const validatorDirPath = path.join(keystoresDir, pubkey);

    if (fs.existsSync(validatorDirPath)) {
      console.log(`Skipping existing validator ${pubkey}`);
      continue;
    }

    console.log(`
Keystore found at ${keystorePath}
- Public key: 0x${pubkey}
- UUID: ${uuid}

If you enter the password it will be stored as plain-text in ${secretsDir} so that it is not \
required each time the validator client starts.
`);
    
    const answers = await inquirer.prompt<{password: string}>([{
      name: "password",
      type: "password",
      message: "Enter the keystore password, or press enter to omit it",
      validate: (input) => {
        try {
          // Accept empty passwords
          if (input) keystore.decrypt(stripOffNewlines(input));
          return true;
        } catch (e) {
          return `Invalid password: ${e.message}`;
        }
      }
    }]);

    console.log("Password is correct");
    await new Promise(r => setTimeout(r, 1000)); // For UX

    fs.mkdirSync(secretsDir, {recursive: true});
    fs.mkdirSync(validatorDirPath, {recursive: true});
    writeFile600Perm(path.join(secretsDir, pubkey), answers.password);
    fs.writeFileSync(path.join(keystoresDir, pubkey, VOTING_KEYSTORE_FILE), keystore.toJSON());

    console.log(`Successfully imported validator ${pubkey}`);
    numOfImportedValidators++;
  }

  if (numOfImportedValidators === 0) {
    console.log("\nAll validators are already imported");
  } else if (keystorePaths.length > 1) {
    const skippedCount = keystorePaths.length - numOfImportedValidators;
    console.log(`\nSuccessfully imported ${numOfImportedValidators} validators (${skippedCount} skipped)`);
  }

  console.log(`
DO NOT USE THE ORIGINAL KEYSTORES TO VALIDATE WITH
ANOTHER CLIENT, OR YOU WILL GET SLASHED.
`);
}
