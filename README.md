# ssz

Simple Serialize (SSZ)

## Install

`npm install @chainsafe/ssz`

## Usage

See [API.md](docs/API.md) for the autogenerated API docs.

In order to properly serialize/deserialize/hash values, we need both the value and the "type" of the value.

### Types

The simple serialization spec operates over a few specific types.
Types are either specified in a simplified form (eg: `"uint32"`) or an extended form. In most cases, the simplified form suffices.

#### Uint
A uint serialization value may be either a js `number` or a `BN` from [bn.js](https://github.com/indutny/bn.js).
A uint type is specified by either `"uintN"` or `"numberN"`, where N is the number of bits to serialize.
`uintN` > 32 bits is deserialized to a `BN` else deserialized to a `number`.
Every `numberN` is deserialized to a number.

#### Boolean
A boolean serialization value must be either `true` or `false`. Anything other input will throw an `Error`.
The boolean type is specified as `"bool"`.

#### Vector
A "vector" according to the spec is a fixed-length list with every element of the same type.
A vector serialization value may be either an `Array` or `Buffer`.
Vector types are specified as either `"bytesN"` or `[elementType, vectorlength]`
`bytesN` is deserialized to `Buffer`.
`[elementType, vectorLength]` is deserialized to `Array<elementType>` unless elementType is `byte`, when the value is deserialized to `Buffer`.

#### List
A "list" according to the spec is a list of unspecified length with every element of the same type.
A list serialization value may be either an `Array` or `Buffer`.
Tuple types are specified as either `"bytes"` or `[elementType]`
`bytes` is deserialized to `Buffer`.
`[elementType]` is deserialized to `Array<elementType>` unless elementType is `byte`, when the value is deserialized to `Buffer`.

#### Container
A "container" according to the spec is a collection of values where the type of each element may differ.
A container serialization value must be an `Object`.
The container serialization type must be an `Object`, with a string `name`, and a `fields` value of `Array<[fieldName, fieldType]>.

#### Extended form

See `SSZType` in `src/types.ts` for more information.

## Examples

### Serialize:

#### Boolean
```typescript
let bool = true
let serialized = ssz.serialize(bool, 'bool')
```

#### Number
```typescript
let num = 16
let serialized = ssz.serialize(num, 'uint32')
```

#### BN (Big Number)
```typescript
const BN = require('bn.js')
let num = new BN(0xFFFFFFFFFFFFFFF0)
let searialized = ssc.serialize(num, 'uint64')
```

Note: Any value greater than `2^53 - 1` should be stored in a [BN](https://github.com/indutny/bn.js)

#### Buffer
```typescript
let bytes = Buffer.from([1,2,3])
let serialized = ssz.serialize(bytes, 'bytes')
```

With `bytesN`:
```typescript
// Note: N === bytes.length
let bytes = Buffer.from([1, 2, 3, 4])
let serialized = ssz.serialize(bytes, 'bytes4')
```

#### Array
```typescript
let array = [1, 2, 3]
let serialized = ssz.serialize(array, ['uint16'])
```

#### Object
```typescript
let obj = {
	a: Buffer.from('hello'),
	b: 10,
	c: false
}

let types = {
	'fields' : [
		['a', 'bytes'],
		['b', 'int16'],
		['c', 'bool'],
	]
}

let serialized = ssz.serialize(obj, types)
```

### Deserialize

For deserialization we need to specify:
- data {Buffer} - encoded data
- type {SerializableType} - type of data we want to decode, same as encoding types

#### Boolean
```typescript
ssz.deserialize(buf, 'bool')
```

#### Number/BN
```typescript
// Deserialize to a BN
ssz.deserialize(buf, 'uint64')

// Deserialize to a js number
// WARNING: this will cause issues if you try to deserialize to a value greater than 2^53-1
ssz.deserialize(buf, 'number64')
```

#### Buffer
```typescript
ssz.deserialize(buf1, 'bytes')
```

#### Array
```typescript
ssz.deserialize(buf1, ['uint32'])
```

#### Object
```typescript
let myType = {
  fields: [
    ['a', 'bool'],
    ['b', 'uint8'],
  ],
}
ssz.deserialize(buf, myType)
```

### Hash Tree Root

To hash an SSZ-serializable function, we need pass in the value and the type, like with `serialize`:

```typescript
ssz.hashTreeRoot(true, 'bool')

ssz.hashTreeRoot(5, 'uint16')

ssz.hashTreeRoot(Buffer.from([1, 2, 3, 4]), 'bytes')

ssz.hashTreeRoot([true, true], ['bool'])

let myType = {
  fields: [
    ['a', 'bool'],
    ['b', 'uint8'],
  ],
}
ssz.hashTreeRoot({a: true, b: 5}, myType)
```

### Signed Root

An object type can be hashed without its final field using `signedRoot`. This is useful if we assume the final field is a signature.

```typescript
let myType = {
  fields: [
    ['a', 'bool'],
    ['b', 'bool'],
    ['c', 'bytes48'],
  ],
}

let data = {
  a: true,
  b: true,
  c: null,
}

let signedRoot = ssz.signedRoot(data, myType)

data.c = privateKey.sign(signedRoot)

// Others can verify by:

publicKey.verify(signedRoot(data, myType))
```

### License

MIT
